import json
import pathlib
import re
import sys
import subprocess

import bs4


"""
This module implements an asciidoc_fake_parse function that uses AsciiDoctor to
convert AsciiDoc to HTML, then correlates positions in the original AsciiDoc
file to the parsed HTML.

The result is something similar to an annotated AST and can be used to do
structural processing of AsciiDoc.
"""


def adoc_to_soup(path):
    return bs4.BeautifulSoup(subprocess.run(["asciidoctor", "-b", "html5", "-a", "experimental", "-e", path, "-o", "-"], check=True, stdout=subprocess.PIPE).stdout, features="html.parser")


def walk(soup):
    yield soup
    if isinstance(soup, bs4.NavigableString):
        return
    for elem in soup.children:
        yield from walk(elem)


def elem_to_path(elem):
    return "/".join([p.name for p in elem.parents])


def asciidoc_fake_parse(path: pathlib.Path):
    text = path.read_text()
    soup = adoc_to_soup(path)
    pos = 0
    blocks = []
    for elem in walk(soup):
        if not isinstance(elem, bs4.NavigableString) or not elem.text.strip():
            continue

        # Some text elements are generated by AsciiDoctor, and don't correspond to content in the original AsciiDoc file

        # skip admonitions
        if elem.text == "Note" and elem.parent.parent.parent.parent.parent.attrs["class"] == ['admonitionblock', 'note']:
            continue
        # skip callouts
        if re.match(r"\(\d+\)", elem.text) and elem.parent.attrs["class"] == ["conum"]:
            continue

        # Once extraneous text elements are skipped, we work line by line on the parsed HTML
        # We do this because line comments are not present in the HTML output
        for i, line in enumerate(elem.text.split("\n")):
            original = line.replace("\xa0", "{nbsp}").replace("â€™", "'")
            elem_position_in_text = text.find(original, pos)
            assert elem_position_in_text != -1, f"can't find {repr(elem.text)}"
            if i == 0:
                blocks.append({"text": text[pos:elem_position_in_text], "path": None, "start": pos})
            blocks.append({"text": original, "path": elem_to_path(elem), "start": elem_position_in_text})
            pos = elem_position_in_text + len(original)
    return blocks


def main():
    print(json.dumps(asciidoc_fake_parse(pathlib.Path(sys.argv[1]))))


if __name__ == "__main__":
    main()
